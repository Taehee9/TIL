# SOLID 원칙

SOLID 원칙이란 객체 지향 프로그래밍 및 설계의 다섯가지 기본 원칙을 마이클 페더스가 소개한 것이다.  
시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 적용할 수 있다.

## SRP(Single Responsibility Principle) : 단일책임 원칙

한 클래스는 하나의 책임만 가져야 한다.

### 객체 지향에서 책임이란?

객체가 할 수 있는 것 또는 해야 하는 것

### SRP 지켜야 하는 이유는?

`영화` 를 주제로 얘기하자면, 

영화라는 Movie 클래스를 만들었을 때 현재 상영하는 영화 보여주고, 영화 예약을 받는 등 다양한 일을 한다.  
이렇게 하나의 클래스가 다양한 책임을 가질 경우 **변경**에 있어서 문제가 일어날 수 있다.

영화를 예매 할 때는 현재 상영하는 영화를 보여주고 가격을 불러와 계산해야 영화 예매가 끝난다.  
이 모든 정보가 한 클래스 안에 있다면, 다른 역할 수행하는 코드끼리 강하게 결합된다. 

만약 할인 정책이 추가되는 것처럼 어떤 변화가 일어나면 하나의 변화에 대해 많은 변경 사항을 발생시키고 관련된 모든 기능을 테스트 해봐야 한다.

이런 문제를 해결하기 위해선 영화-예매-가격 처럼 클래스를 쪼개어 관리하면 변경에 유연하게 대체할 수 있다. 

## OCP(Open-Closed Principle) : 개방-폐쇄 원칙

확장에는 열려 있고 변경에는 닫혀있어야 한다.

### OCP 예제

위와 똑같은 영화 예제를 들자면,

원래는 영화 예매시 모두에게 10% 할인을 했었다. 그런데 갑자기 할인 정책이 바뀌어 통신사 할인이 추가됐다. 

이 때 OCP를 지키지 않고 코드를 했다면 10% 할인으로 고정되어있는 부분을 통신사 쓸건지 체크하고 통신사 할인을 진행하는 코드가 추가될 것이다.

이럴 때 OCP를 지켜 할인정책이라는 인터페이스로 분리한다면 통신사 할인 후에 카드 할인처럼 다른 할인 정책이 추가될 때에도 유연하게 대응이 가능해진다.

## LSP(Liskov Substitution Principle) : 리스코프 치환 원칙

상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

## ISP(Interface Segregation Principle) : 인터페이스 분리 원칙

인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

## DIP(Dependency Inversion Principle) : 의존관계 역전 원칙

고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

### 참고
[SOLID (객체 지향 설계)](https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84))  
[객체지향 SOLID 원칙 이란?](https://velog.io/@kyle/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-SOLID-%EC%9B%90%EC%B9%99-%EC%9D%B4%EB%9E%80)
