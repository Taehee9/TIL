# SOLID 원칙

SOLID 원칙이란 객체 지향 프로그래밍 및 설계의 다섯가지 기본 원칙을 마이클 페더스가 소개한 것이다.  
시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 적용할 수 있다.

## SOLID 원칙 5가지

1. **S**ingle Responsibility (단일책임)
2. **O**pen-Closed (개방-폐쇄)
3. **L**iskov Substitution (리스코프 치환)
4. **I**nterfae Segregation (인터페이스 분리)
5. **D**ependency Inversion (의존관계 역전)

## SRP(Single Responsibility Principle) : 단일책임 원칙

한 클래스는 하나의 책임만 가져야 한다.  
책임 하나만 가지면 그 클래스를 변경해야 할 때 변경 해야하는 이유는 한 가지

### 객체 지향에서 책임이란?
객체가 할 수 있는 것 또는 해야 하는 것

### SRP 지켜야 하는 이유는?
1. 테스트 할 때 책임이 하나이기 때문에 테스트 수가 감소
2. 결합도가 낮아져서 변경이 쉬움
3. 작고 잘 구성된 클래스가 검색하기 쉬움

### 예시
은행을 주제로 예시를 들어보겠다.  
Bank 클래스를 만들 때 계좌를 생성할 수도 있고, 소유주가 가지고 있는 계좌를 볼 수도 있으며 입금, 출금도 할 수 있다.  
이렇게 다양한 책임들이 한 클래스 안에 있으면 다른 역할을 수행하는 코드끼리 강하게 결합되므로 **변경**에 있어서 문제가 생길 수 있다.

A가 B한테 입금을 하게 된다면 A한테는 출금, B한테는 입금이 되는데, 이 과정에서 다양한 책임들이 한 클래스에 있음으로 인해 입금 과정에서 출금, 입금이 모두 이뤄지게 된다.  
만약에 출금 정책이 바뀌게 된다면 출금만 바꾸는 것이 아니라 입금에 있는 출금 쪽도 봐야할 수도 있다. 관련된 모든 기능들을 테스트 해봐야하고 중복 코드가 발생할 수도 있으며 여러 부분에서 많은 시간과 비용이 든다.  

이런 문제를 해결하기 위해선 **입금 - 출금** 으로 클래스를 쪼개어 관리한다면 변경에 유연하게 대처할 수 있을 것이다.

## OCP(Open-Closed Principle) : 개방-폐쇄 원칙

확장에는 열려 있고 변경에는 닫혀있어야 한다.

### OCP 예제

위와 똑같은 은행을 가지고 예시를 들어보자면,

원래는 기본 계좌 생성하는 부분이 있었다. 그런데 이번에 이벤트로 금리를 조금 높여서 계좌를 생성한다고 한다.  

이 때 Account 계좌만 만들어놨다면, Account라는 추상 클래스를 만들고 그 아래로 BasicAccount, EventAccount 클래스들을 만들고 Account를 상속 받는다면, 나중에 다른 종류의 계좌가 추가됐을 때도 쉽게 변경이 가능해진다.

## LSP(Liskov Substitution Principle) : 리스코프 치환 원칙

상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.   
= 서브 클래스의 객체가 수퍼 클래스의 객체와 동일한 방식으로 작동

### LSP를 지켰는지 확인 하는 방법

테스트 할 때 모든 하위 클래스의 객체로 애플리케이션의 특정 부분을 실행해 오류를 일으키거나 성능을 크게 변경하지 않는지 확인한다.

### LSP 예제

은행 예제로 계속 얘기해보겠다.

Account 클래스에서 입출금 기본 계좌를 만들었는데, 저축성 계좌를 추가하려고 한다.  
그런데 저축성 계좌는 출금이 안된다.  
이렇게 됐을 경우에 LSP 를 어기게 된다.

이럴 때는 Account 밑에 출금 가능 계좌와 출금 안되는 저축성 계좌로 분리하고, 출금 가능 계좌에서 기본 계좌와 이벤트 계좌 이런식으로 나뉘어진다면 출금 부분을 상속하지 않기 때문에 LSP 를 지킬 수 있어진다.

### 피터 코드의 상속 규칙

LSP를 지키다보면 피터 코드의 상속 규칙 중   
자식 클래스가 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행해야 한다.  
는 규칙도 지키게 된다.

피터 코드의 상속 규칙은 나중에 다시 자세히 공부해보는 걸로 하자!

## ISP(Interface Segregation Principle) : 인터페이스 분리 원칙

큰 인터페이스를 더 작은 인터페이스로 분할해야 한다. 클래스를 구현하는 데 관심 있는 메서드만 관심을 갖게 할 수 있다.

### 예시

LSP 규칙처럼 저축성 계좌가 추가 되었을 때  
출금이라는 부분이 인터페이스로 따로 빠져있었다면 좀 더 자유롭게 구현이 가능했을 것이다.  
이런 것처럼 더 작은 인터페이스로 분리한다면 유지 보수나 확장이 좀 더 쉬워진다.

## DIP(Dependency Inversion Principle) : 의존관계 역전 원칙

고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

### 고수준 모듈

상위에 있는 모듈을 말하는 것으로 '입금', '카드 결제' 이런 것처럼 좀 더 포괄적이다.

### 저수준 모듈

하위에 있는 모듈로 '특정 은행 입금' 처럼 세부적인 것들이다.

### 예시

입금 부분으로 예시를 들어보자면,

입금 - 국민은행  
으로 연관이 되어있다고 해보자.

은행의 입금 부분이 국민은행 입금부분만 구현이 되어있는 상태이고, 추가로 신한은행이 추가된다면 입금 부분도 수정해야한다.  

**입금 - 은행코드 - 국민은행 / 신한은행**  
이런식으로 바꿔준다면 다른 은행들이 추가되더라도 기존 코드의 영향을 받지 않고 추가할 수 있다.

### 참고

[A Solid Guide to SOLID Principles | Baeldung](https://www.baeldung.com/solid-principles)  
[SOLID (객체 지향 설계)](https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84))  
[객체지향 SOLID 원칙 이란?](https://velog.io/@kyle/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-SOLID-%EC%9B%90%EC%B9%99-%EC%9D%B4%EB%9E%80)


#### 느낀점
예시를 드는게 가장 어려운 일인 것 같다.  
이해한 상황에서 최대한 예시를 하나로 쭉 이어서 들어보려고 노력하다보니 뭔가 예시가 적합하지 않을 수도 있다고 생각한다.  
나중에 더 공부한 후에 보면서 예시를 수정할 수 있음 수정해야겠다.
